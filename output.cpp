#include "output.h"
#include <iostream> // For standard input and output
#include <time.h>   // For time(), gmtime(), localtime(), asctime()...
#include <fstream>  // For ofstream file
#include <sstream>  // For stringstreams
#include <math.h>   // For log()
#include <ctime>    // For strptime()
#include <time.h>   // FOr time_t, struct tm, time, mktime()

#define HOURS_DIFFERENCE_UTC_EST -5

static std::string startHTML = "<!DOCTYPE html><html><style>table{font-family: arial, sans-serif;border-collapse: collapse;width: 60%;table-layout: fixed;background-color:#e7e7e7;}td,th{border: 1px solid #dddddd;text-align: center;padding: 8px;width: 50%;}</style><body style=\"background-color:#a2b9c2\"><h1 style=\"text-align:center\">Storing devices report</h1><br><p style=\"text-align: center;\">Report auto-generated with information about USBs connected to this computer since startup, including times when they were connected and disconnected, if that is the case. The information from this devices is gathered from Linux event logs.</p><p style=\"text-align: center;\">It also displays information about the hard drives connected to the computer, getting the information of these with ioctl Linux tool.</p><br><br><br><br><br><h2 style=\"text-align:center\">USBs</h2>";
static std::string beforeHardDisks = "<br><br><br><h2 style=\"text-align:center\">Hard drives</h2>";
static std::string endHTML = "<br><br><br><p style=\"text-align: right;\">Report generated by ____ tool developed by j0sem1 as part of ____ Master's thesis.</p></body></html>";

static std::string usb_connected = "red;\">Not connected";
static std::string usb_serial_number = "Serial number not found";
static std::string usb_product_name = "Product name not found";
static std::string usb_manufacturer = "Manufacturer not found";
static std::string usb_vendor_id = "Vendor ID not found";
static std::string usb_product_id = "Product ID not found";
static std::string usb_localtime_connection = "";
static std::string usb_localtime_disconnection = "";
static std::string usb_utc_connection = "";
static std::string usb_utc_disconnection = "";
static std::string usb_est_connection = "";
static std::string usb_est_disconnection = "";
static std::string disk_path = "Unknown disk";
static std::string disk_interface = "Interface not found";
static std::string disk_product = "Product not found";
static std::string disk_version = "Version not found";
static std::string disk_firmware_version = "Firmware not found";
static std::string disk_serial_number = "Serial number not found";
static std::string disk_size = "Size not found";

std::string month[12] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};


// Got from ChatGPT
std::tm convertSyslogTimestampToTm(std::string input_str) {

    std::tm t = {};
    char const* format = "%b %d %T";
    strptime(input_str.c_str(), format, &t);

    return t;
}

std::tm getUTCTimeFromLocalTime(std::tm local_time) {

    // time_t auxiliar variable needed to convert in different timezones
    time_t time_t_aux;
    // tm auxiliar variable needed to convert in different timezones
    std::tm* tm_aux;
    // tm variable which will contains at the end the date in UTC timezone
    struct tm *utc;

    // Get local time with correct timezone and other parameters in time_t data type
    time(&time_t_aux);

    // Convert that time_t variable into tm to set the values passed by parameter
    tm_aux = localtime(&time_t_aux);
    tm_aux->tm_mon = local_time.tm_mon;
    tm_aux->tm_mday = local_time.tm_mday;
    tm_aux->tm_hour = local_time.tm_hour;
    tm_aux->tm_min = local_time.tm_min;
    tm_aux->tm_sec = local_time.tm_sec;

    // Convert again that tm data type into time_t to be able to use gmtime() function and convert that date into UTC
    time_t_aux = mktime(tm_aux);

    // Convert the time_t data type into tm to be able to work with it
    utc = gmtime(&time_t_aux);

    // Return variable as value, not as reference
    return *(utc);
}

std::tm getESTTimeFromUTCTime(std::tm utc) {

    // time_t auxiliar variable needed to convert in different timezones
    time_t time_t_aux;
    // tm auxiliar variable needed to convert in different timezones
    std::tm* tm_aux;

    // Get local time with correct timezone and other parameters in time_t data type
    time(&time_t_aux);

    // Convert that time_t variable into tm to set the values passed by parameter
    tm_aux = localtime(&time_t_aux);
    tm_aux->tm_mon = utc.tm_mon;
    tm_aux->tm_mday = utc.tm_mday;
    tm_aux->tm_hour = utc.tm_hour;
    tm_aux->tm_min = utc.tm_min;
    tm_aux->tm_sec = utc.tm_sec;

    // Convert again that tm data type into time_t to add or subtract the necessary hours and see the change in days or months automatically
    time_t_aux = mktime(tm_aux);

    // Add or subtract the difference in hours between UTC and EST timezones (3600 seconds per hour)
    time_t_aux += HOURS_DIFFERENCE_UTC_EST * 3600;

    // Convert time_t back to tm
    tm_aux = localtime(&time_t_aux);

    // Return variable as value, not as reference
    return *(tm_aux);
}

std::string GetStringFromTM(std::tm date) {

    std::ostringstream date_stringstream;
    
    date_stringstream << month[date.tm_mon] << " " << date.tm_mday << " at " << date.tm_hour << ":" << date.tm_min << ":" << date.tm_sec;

    return date_stringstream.str();
}

// Got from: https://gist.github.com/haohaozaici/7fddba2d7f1038bd578cb6acf5c57ac0
// si - international system of units   
std::string humanReadableByteCount(unsigned long long bytes, bool si) {
    unsigned long long unit = si ? 1000 : 1024;
    if (bytes < unit)
        return bytes + " B";
    int exp = (int) (log(bytes) / log(unit));
    std::string pre = ((std::string) (si ? "kMGTPE" : "KMGTPE"))[exp-1] + ((std::string) (si ? "" : "i"));
    char result[100];
    sprintf(result, "%.1llu %sB", bytes / (unsigned long long) pow(unit, exp), pre.c_str());
    return result;
}

void initializeUSBVariables() {
    usb_connected = "red;\">Not connected";
    usb_serial_number = "Serial number not found";
    usb_product_name = "Product name not found";
    usb_manufacturer = "Manufacturer not found";
    usb_vendor_id = "Vendor ID not found";
    usb_product_id = "Product ID not found";
}

void initializeUSBTimes() {
    usb_localtime_connection = "";
    usb_localtime_disconnection = "";
    usb_utc_connection = "";
    usb_utc_disconnection = "";
    usb_est_connection = "";
    usb_est_disconnection = "";
}

void initializeDiskVariables() {
    disk_path = "Unknown disk";
    disk_interface = "Interface not found";
    disk_product = "Product not found";
    disk_version = "Version not found";
    disk_firmware_version = "Firmware not found";
    disk_serial_number = "Serial number not found";
    disk_size = "Size not found";
}

void printHTML(std::map<std::string, usbInfo> usbs_map, std::map<std::string, hardDiskInfo> disks_map) {

    std::ofstream out("report.html");
    int usb_iterator = 1;
    std::map<std::string, usbInfo>::iterator usbs_it;
    std::list<std::string>::iterator it_time_connection;
    std::list<std::string>::iterator it_time_disconnection;
    std::map<std::string, hardDiskInfo>::iterator disks_it;
    bool at_least_one_disk_found = false;

    out << startHTML;

    /*
        USBs loop
    */
    for (usbs_it = usbs_map.begin(); usbs_it != usbs_map.end(); ++usbs_it) {

        if (usbs_it->second.idVendor) {
            usb_vendor_id = std::to_string(usbs_it->second.idVendor);
        }
        if (usbs_it->second.idProduct) {
            usb_product_id = std::to_string(usbs_it->second.idProduct);
        }
        if (usbs_it->second.productName != "") {
            usb_product_name = usbs_it->second.productName;
        }
        if (usbs_it->second.manufacturer != "" && usbs_it->second.manufacturer.find_first_not_of(' ') != std::string::npos) {
            usb_manufacturer = usbs_it->second.manufacturer;
        }
        if (usbs_it->second.serialNumber != "") {
            usb_serial_number = usbs_it->second.serialNumber;
        }
        if (usbs_it->second.connectionTimes.size() > usbs_it->second.disconnectionTimes.size()) {
            usb_connected = "green;\">Connected";
        }

        std::ostringstream usb_info_table_stringstream;
        usb_info_table_stringstream << "<table align=\"center\"><tr style=\"background-color:#dadada;\"><th style=\"font-size:20px;\">USB " << usb_iterator
            << "</th><th style=\"color: " << usb_connected
            << "</th></tr><tr><td style=\"background-color:#dadada\"><b>Serial Number</b></td><td>" << usb_serial_number
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Product Name</b></td><td>" << usb_product_name
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Manufacturer</b></td><td>" << usb_manufacturer
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Vendor ID</b></td><td>" << usb_vendor_id
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Product ID</b></td><td>" << usb_product_id
            << "</td></tr></table>";
        std::string usb_info_table_string = usb_info_table_stringstream.str();

        out << usb_info_table_string;

        /*
            USB times
        */
        std::string usb_all_times_only = "";

        it_time_connection = usbs_it->second.connectionTimes.begin();
        it_time_disconnection = usbs_it->second.disconnectionTimes.begin();

        while (it_time_connection != usbs_it->second.connectionTimes.end()) {

            usb_localtime_connection = GetStringFromTM(convertSyslogTimestampToTm((*it_time_connection)));
            usb_utc_connection = GetStringFromTM(getUTCTimeFromLocalTime(convertSyslogTimestampToTm((*it_time_connection))));
            usb_est_connection = GetStringFromTM(getESTTimeFromUTCTime(getUTCTimeFromLocalTime(convertSyslogTimestampToTm((*it_time_connection)))));

            if (it_time_disconnection != usbs_it->second.disconnectionTimes.end()) {
                usb_localtime_disconnection = GetStringFromTM(convertSyslogTimestampToTm((*it_time_disconnection)));
                usb_utc_disconnection = GetStringFromTM(getUTCTimeFromLocalTime(convertSyslogTimestampToTm((*it_time_disconnection))));
                usb_est_disconnection = GetStringFromTM(getESTTimeFromUTCTime(getUTCTimeFromLocalTime(convertSyslogTimestampToTm((*it_time_disconnection)))));
                it_time_disconnection++;
            }
            it_time_connection++;

            std::ostringstream usb_individual_time_table_stringstream;
            usb_individual_time_table_stringstream << "<tr>"
            << "<td><time>" << usb_localtime_connection << "</time></td>"
            << "<td><time>" << usb_localtime_disconnection << "</time></td>"
            << "<td><time>" << usb_utc_connection << "</time></td>"
            << "<td><time>" << usb_utc_disconnection << "</time></td>"
            << "<td><time>" << usb_est_connection << "</time></td>"
            << "<td><time>" << usb_est_disconnection << "</time></td>"
            << "</tr>";
            std::string usb_individual_time_table_string = usb_individual_time_table_stringstream.str();
            usb_all_times_only = usb_all_times_only + usb_individual_time_table_string;

            initializeUSBTimes();

        }

        std::ostringstream usb_all_times_table_stringstream;
        
        std::string usb_times_table_string = 
            "<p style=\"text-align: center;\">Connection and disconnection times in different time zones:</p><table align=\"center\"><tr><th colspan=\"2\" style=\"background-color:#dadada\">Local time</th><th colspan=\"2\" style=\"background-color:#dadada\">UTC</th><th colspan=\"2\" style=\"background-color:#dadada\">EST</th></tr><tr><th style=\"background-color:#dadada\"><b>Conections</b></th><th style=\"background-color:#dadada\"><b>Disconnections</b></th><th style=\"background-color:#dadada\"><b>Conections</b></th><th style=\"background-color:#dadada\"><b>Disconnections</b></th><th style=\"background-color:#dadada\"><b>Conections</b></th><th style=\"background-color:#dadada\"><b>Disconnections</b></th></tr>"
            +
            usb_all_times_only
            +
            "</table><br><br><br><br>";

        out << usb_times_table_string;

        usb_iterator++;

        initializeUSBVariables();

    }

    out << beforeHardDisks;

    /*
        Disks loop
    */
    for (disks_it = disks_map.begin(); disks_it != disks_map.end(); ++disks_it) {

        if (!disks_it->second.isEmpty) {

            at_least_one_disk_found = true;

            disk_path = disks_it->first;
            disk_interface = disks_it->second.diskType;
            if (disks_it->second.product != "") {
                disk_product = disks_it->second.product;
            }
            if (disks_it->second.version != "") {
                disk_version = disks_it->second.version;
            }
            if (disks_it->second.firmware != "") {
                disk_firmware_version = disks_it->second.firmware;
            }
            if (disks_it->second.serialNumber != "") {
                disk_serial_number = disks_it->second.serialNumber;
            }
            if (disks_it->second.size != 0) {
                disk_size = humanReadableByteCount(disks_it->second.size, true);
            }

            std::ostringstream disk_info_table_stringstream;
            disk_info_table_stringstream << "<table align=\"center\"><tr style=\"background-color:#dadada\"><th style=\"font-size:20px;\">" << disk_path
            << "</th><th></th></tr><tr><td style=\"background-color:#dadada\"><b>Disk interface</b></td><td>" << disk_interface
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Product</b></td><td>" << disk_product
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Version</b></td><td>" << disk_version
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Firmware version</b></td><td>" << disk_firmware_version
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Serial number</b></td><td>" << disk_serial_number
            << "</td></tr><tr><td style=\"background-color:#dadada\"><b>Size</b></td><td>" << disk_size
            << "</td></tr></table><br><br><br><br>";
            std::string disk_info_table_string = disk_info_table_stringstream.str();

            out << disk_info_table_string;

        }

        initializeDiskVariables();

    }

    if (!at_least_one_disk_found) {
        out << "<p style=\"text-align: center;\">Disks info not found.</p>";
    }

    out << endHTML;

    out.close();
}

void printUSBsMapInTerminal(std::map<std::string, usbInfo> usbs_map) {

    std::map<std::string, usbInfo>::iterator it;
    int n = 1;

    for (it = usbs_map.begin(); it != usbs_map.end(); ++it){
        std::cout << "||| USB " << n << " |||" << std::endl;

        std::list<std::string>::iterator it_time;

        std::cout << "Connection times:" << std::endl;
        for (it_time = it->second.connectionTimes.begin(); it_time != it->second.connectionTimes.end(); ++it_time){
            std::cout << "   " << (*it_time) << std::endl;
        }

        std::cout << "Disconnection times:" << std::endl;
        for (it_time = it->second.disconnectionTimes.begin(); it_time != it->second.disconnectionTimes.end(); ++it_time){
            std::cout << "   " << (*it_time) << std::endl;
        }
        
        if (!it->second.idVendor){
            std::cout << "Vendor ID not found" << std::endl;
        } else {
            std::cout << "Vendor ID: " << it->second.idVendor << std::endl;
        }
        if (!it->second.idProduct){
            std::cout << "Product ID not found" << std::endl;
        } else {
            std::cout << "Product ID: " << it->second.idProduct << std::endl;
        }
        if (it->second.productName == ""){
            std::cout << "Product name not found" << std::endl;
        } else {
            std::cout << "Product name: " << it->second.productName << std::endl;
        }
        if (it->second.manufacturer == "" || it->second.manufacturer.find_first_not_of(' ') == std::string::npos){
            std::cout << "Manufacturer not found" << std::endl;
        } else {
            std::cout << "Manufacturer: " << it->second.manufacturer << std::endl;
        } if (it->second.serialNumber == ""){
            std::cout << "Serial number not found" << std::endl;
        } else {
            std::cout << "Serial number: " << it->second.serialNumber << std::endl;
        }
        std::cout << std::endl;

        n++;
    }
}

void printDisksMapInTerminal(std::map<std::string, hardDiskInfo> disks_map) {

    std::map<std::string, hardDiskInfo>::iterator it;

    for (it = disks_map.begin(); it != disks_map.end(); ++it){
        if (!it->second.isEmpty){
            std::cout << "||| " << it->first << " |||" << std::endl;
            std::cout << "Disk interface: " << it->second.diskType << std::endl;
            if (it->second.product == ""){
                std::cout << "Product not found" << std::endl;
            } else {
                std::cout << "Product: " << it->second.product << std::endl;
            }
            if (it->second.version == ""){
                std::cout << "Version not found" << std::endl;
            } else {
                std::cout << "Version: " << it->second.version << std::endl;
            }
            if (it->second.firmware == ""){
                std::cout << "Firmware version not found" << std::endl;
            } else {
                std::cout << "Firmware version: " << it->second.firmware << std::endl;
            }
            if (it->second.serialNumber == ""){
                std::cout << "Serial number not found" << std::endl;
            } else {
                std::cout << "Serial number: " << it->second.serialNumber << std::endl;
            }
            if (it->second.size == 0){
                std::cout << "Size not found" << std::endl;
            } else {
                std::cout << "Size: " << humanReadableByteCount(it->second.size, true) << std::endl;
            }
            std::cout << std::endl;
        }
    }

}